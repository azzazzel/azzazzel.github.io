---
layout: post
title: 'Writing Liferay portlet to display a file in a way "tail -f" does  '
date: '2010-05-04 00:10:42 +0200'
mt_id: 11
blog_id: 1
post_id: 11
basename: writing_liferay_portlet_to_display_a_file_in_a_way_tail_-f_does
categories:
- tips_and_tricks
- liferay
---
<p><meta http-equiv="content-type" content="text/html; charset=utf-8" /></p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">Don't know about you but I can't imagine debugging enterprise class applications without having &quot;<span style="font-family: 'Courier New'; ">tail -f /path/to/log.file</span>&quot; running in dedicated console window. During development and testing phases (assuming work is done &quot;in house&quot;) there is usually no problem with this approach as the whole team have access to servers' log files. This is not always the case with staging and production environments though. These days a lot of companies execute strong security policies which sometimes means that application is only accessible via HTTP. In such case, depending on how you SLA looks like, &quot;<i>log files provided on demand via e-mail or FTP</i>&quot; may not be an option.&nbsp;</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">Facing this kind of problem in recent Liferay based project, made me think about creating a portlet capable of displaying log files. Something like WWW based version of &quot;tail -f&quot;. This is how Tailgate was born (for those of you looking for solution here is <a href="http://github.com/azzazzel/Liferay-plugins/downloads">download page</a>). The rest of this post will concentrate on explaining why it was not &quot;<i>a max 2h of coding</i>&quot; as I thought in the begging.</p>

<!--more-->

<p style="text-align: justify; ">Tailgate portlet needs to dynamically show new lines as they are written to the file without reloading the whole portal page. Assuming one portlet instance is configured to display only one file, the solution appears to be straightforward and rather simple: <meta http-equiv="content-type" content="text/html; charset=utf-8" /></p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; "><code class="blockWhite">while page is displayed {<br /> &nbsp;browser sends AJAX request<br /> &nbsp;server checks if there are new lines in given file &nbsp;<br /> &nbsp;server responds with list of new lines<br /> &nbsp;browser adds lines to appropriate DOM element<br /> }</code>While this is in general the whole functionality, there are a few things to consider on both front-end (client) and back-end (server) side. &nbsp;</p> <h2><b><span style="font-size: large; ">front-end</span></b></h2> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; ">As far as front-end is concern there are 2 main things to consider:&nbsp;</p> <h3><span style="font-size: small; "><u><b>Multiple instances on the same page</b></u></span></h3> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">This is a bit tricky and requires good understanding of how portals work. When a portlet is developed it contains common code for all instances. So if multiple instance can be placed on the same portal page then the common code should be able to distinguish instances. This is even more important with AJAX requests. &nbsp;&nbsp;</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">In this case we have a common logic for sending and receiving AJAX requests and updating DOM model. However when portlet instance sends AJAX requests it needs to provide instance specific set of parameters as part of the URL. Also when response is received only DOM elements belonging to this particular instance need to be updated.</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">The common JavaScript code is provided in <span style="font-family: 'Courier New'; ">tailgate.js</span> file. The portlet uses also <a href="http://plugins.jquery.com/project/timers">jQuery timers module</a> (<span style="font-family: 'Courier New'; ">jquery.timers.js</span>) which provides high level abstraction of setTimeout and setInterval. These files are part of the portlet code. Including them in <span style="font-family: 'Courier New'; ">HTML</span> page is done by adding&nbsp;</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><code class="blockWhite">&lt;header-portlet-javascript&gt;/js/jquery.timers.js&lt;/header-portlet-javascript&gt;<br /> &lt;header-portlet-javascript&gt;/js/tailgate.js&lt;/header-portlet-javascript&gt;</code></p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">to <span style="font-family: 'Courier New'; ">WEB-INF/liferay-portlet.xml</span>. This way Liferay will add appropriate links in <span style="font-family: 'Courier New'; ">HEAD</span> section of <span style="font-family: 'Courier New'; ">HTML</span> page and will do this only once regardless of how many portlet instances page contains.</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">The <span style="font-family: 'Courier New'; ">tailgate.js</span>&nbsp;defines the Tailgate object and&nbsp;<span style="font-family: 'Courier New'; ">tailgateInstances</span>&nbsp;map for holding information about Tailgate instances:</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><code class="blockWhite">var tailgateInstances = new Array();&nbsp;<br /> function Tailgate(lines, url) {<br /> <span class="Apple-tab-span" style="white-space: pre; ">	</span>this.lines=lines<br /> <span class="Apple-tab-span" style="white-space: pre; ">	</span>this.url=url<br /> }</code></p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; ">When portlet instance is rendered it takes care to prefix DOM element ids with it's namespace</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><code class="blockWhite">&lt;button id=&quot;&lt;portlet:namespace /&gt;_start&quot;&gt;Start&lt;/button&gt;<br /> &lt;button id=&quot;&lt;portlet:namespace /&gt;_stop&quot;&gt;Stop&lt;/button&gt;<br /> ...<br /> &lt;ul id=&quot;&lt;portlet:namespace /&gt;list&quot; class=&quot;tailgate&quot;&gt;&nbsp;</code></p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; ">, add itself to <span style="font-family: 'Courier New'; ">tailgateInstances</span>&nbsp;map &nbsp;&nbsp;</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><code class="blockWhite">&lt;script type=&quot;text/javascript&quot;&gt;<br /> <span class="Apple-tab-span" style="white-space: pre; ">	</span>tailgateInstances[&quot;&lt;portlet:namespace /&gt;&quot;] =<br /> &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new Tailgate(&lt;%=prefs.getValue(&quot;lines&quot;,&quot;100&quot;)%&gt;, &quot;&lt;liferay-portlet:resourceURL /&gt;&quot;);&nbsp;</code></p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; ">&nbsp;and pass the namespace to called functions</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><code class="blockWhite"><span class="Apple-tab-span" style="white-space: pre; ">	</span>jQuery(&quot;#&lt;portlet:namespace /&gt;_start&quot;).click(function(){<span class="Apple-tab-span" style="white-space: pre; ">		</span>startReading(&quot;&lt;portlet:namespace /&gt;&quot;);<br /> <span class="Apple-tab-span" style="white-space: pre; ">	</span>})<br /> <span class="Apple-tab-span" style="white-space: pre; ">	</span>jQuery(&quot;#&lt;portlet:namespace /&gt;_stop&quot;).click(function(){<br /> <span class="Apple-tab-span" style="white-space: pre; ">		</span>stopReading(&quot;&lt;portlet:namespace /&gt;&quot;);<br /> <span class="Apple-tab-span" style="white-space: pre; ">	</span>})<br /> &lt;/script&gt;&nbsp;</code></p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">Note that all functions in <span style="font-family: 'Courier New'; ">tailgate.js</span> are designed to accept namespace as parameter. This way when called they can either get appropriate Tailgate instance from <span style="font-family: 'Courier New'; ">tailgateInstances</span> map and then check for given property (for example url), or find and update DOM elements prefixed with this namespace.&nbsp;</p> <h3><u><b>Control the CPU and memory usage</b></u></h3> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">Monitored file can change very fast (application could add few megabytes is just a second) therefore at first it seems to be very important to query back-end as often as possible. &nbsp;This however results in very high CPU usage. In fact going down below 10ms may force you to kill your browser in order to recover your system. Experimenting with different values I finally decided that refresh rate of one second is a reasonable compromise.&nbsp;</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">Another thing is memory. If lines are only added but never deleted then after a while the browser will be trying to display a tens of megabytes of <span style="font-family: 'Courier New'; ">HTML</span> code. Therefore Tailgate is configured to only display last <span style="font-family: 'Courier New'; ">X</span> lines. It renders each line as <span style="font-family: 'Courier New'; ">&lt;li&gt;</span> element and when new line is added, a new <span style="font-family: 'Courier New'; ">&lt;li&gt;</span> element is added to the parent <span style="font-family: 'Courier New'; ">&lt;ul&gt;</span>. Then it checks the size of <span style="font-family: 'Courier New'; ">&lt;ul&gt;</span> and if it's bigger than <span style="font-family: 'Courier New'; ">X</span>, old lines are deleted from DOM model. Luckily <a href="http://jquery.com/">jQuery</a> comes with convenient methods so this is really easy to implement:&nbsp;</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><code class="blockWhite"><span class="Apple-tab-span" style="white-space: pre; ">	</span>jQuery('#'+namespace+'list').append(data);<br /> &nbsp;<br /> <span class="Apple-tab-span" style="white-space: pre; ">	</span>var maxLines = tailgateInstances[namespace].lines;<br /> <span class="Apple-tab-span" style="white-space: pre; ">	</span>var lines = jQuery('#' + namespace + 'list li').length;<br /> <span class="Apple-tab-span" style="white-space: pre; ">	</span>if (lines &gt; maxLines) {<br /> <span class="Apple-tab-span" style="white-space: pre; ">		</span>jQuery('#' + namespace + 'list li').slice(0, lines - maxLines).remove();<br /> <span class="Apple-tab-span" style="white-space: pre; ">	</span>}</code></p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; ">&nbsp;</p> <h2><b><span style="font-size: large; ">back-end</span></b></h2> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">The line <i>&quot;server checks if there are new lines in given file&quot;</i> in the above pseudo algorithm is also way oversimplified.&nbsp;</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">The <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/io/RandomAccessFile.html">RandomAccessFile</a>&nbsp;class provides the functionality to position at specific place in file and start reading. However creating a new instance on every request is not a very smart thing to do. Even if it is somehow cached per portlet instance, there still could be many instances monitoring the same file <i>(in the future each may provide different filtering, highlighting, etc.)</i> Also, depending on what file system is used <i>(for example old versions of NFS)</i>, there may be some locking issues when multiple threads try to access the given file at the same time. Therefore it looks like the optimal solution would be to have one thread continuously reading the file and updating in memory buffers provided by specific instances. Here is the activity diagram: &nbsp;</p> <p><img alt="Tailgate activity diagram" width="700" src="/assets/2010-05-04-writing_liferay_portlet_to_display_a_file_in_a_way_tail_-f_does/TailgateActivityDiagram.png" /></p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; ">This looks simple enough but again there are a couple of things to think about:</p> <h3><u><b>synchronization</b></u></h3> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">Since there are two thread operating on the same buffer (one writing and one reading) the buffer's read and write operations need to be synchronized. Otherwise a typical <a href="http://java.sun.com/docs/books/tutorial/essential/concurrency/memconsist.html">Memory Consistency Errors</a>&nbsp;may occur. &nbsp;</p> <h3><u><b>buffer size</b></u></h3> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">Buffers need to have fixed size in order to avoid memory leaks! Since the front-end also displays a limited amount of data, the same configuration parameter can be used to define both the number of lines displayed and buffered. Then every time a new line is added to the the oldest one is removed if buffer the size is reached:</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><code class="blockWhite"><span class="Apple-tab-span" style="white-space: pre; ">	</span>public boolean addLine(final String line) {<br /> <span class="Apple-tab-span" style="white-space: pre; ">		</span>boolean result;<br /> <span class="Apple-tab-span" style="white-space: pre; ">		</span>synchronized (buffer) {<br /> <span class="Apple-tab-span" style="white-space: pre; ">			</span>result = buffer.add(line);<br /> <span class="Apple-tab-span" style="white-space: pre; ">			</span>if (buffer.size() &gt; maxSize) {<br /> <span class="Apple-tab-span" style="white-space: pre; ">				</span>buffer.remove();<br /> <span class="Apple-tab-span" style="white-space: pre; ">			</span>}<br /> <span class="Apple-tab-span" style="white-space: pre; ">		</span>}<br /> <span class="Apple-tab-span" style="white-space: pre; ">		</span>return result;<br /> <span class="Apple-tab-span" style="white-space: pre; ">	</span>}&nbsp;</code></p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; ">&nbsp;</p> <h3><u><b>when to stop reading</b></u></h3> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">If you have carefully examined the activity diagram above you may have noticed that buffers are never unregistered. This is not an error, it is simply impossible to tell when a buffer is no longer needed. One may argue that user could send us appropriate message by clicking on something saying <i>&quot;I'm done watching, please stop the buffer!&quot;</i>. My experience shows such approach is often misunderstood and misused <i>(by that I mean used too often or not at all)</i>. So how can one prevent <span style="font-family: 'Courier New'; ">FileMonitor</span> thread from running forever<i> (it will run as long as there are buffers)</i>? Let the garbage collector do it's job!&nbsp;</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">Buffers are stored in portlet sessions, so instead of relaying on user interaction, Tailgate relays on buffers being garbage collected once portlet session is closed. As you probably know an object becomes eligible for garbage collection when there are no hard references to it. Is this the case with buffers? As the diagram shows, buffers are referenced in 2 other places (marked in red) - <span style="font-family: 'Courier New'; ">FileMonitoringEngine</span> needs to keep track of which buffer is assigned to which monitor and <span style="font-family: 'Courier New'; ">FileMonitor</span> needs to maintain a list of buffers to write to. But here is the difference, in order to leverage the garbage collector's ability to determine buffers' reachability, both <span style="font-family: 'Courier New'; ">FileMonitoringEngine</span> and <span style="font-family: 'Courier New'; ">FileMonitor</span> use weak references. <span style="font-family: 'Courier New'; ">FileMonitoringEngine</span> uses in fact standard WeakHashMap to store the mapping. &nbsp;<span style="font-family: 'Courier New'; ">FileMonitor</span> only needs a Set of weak references but there is no WeakHashSet class. In JDK 6 there is a convenient &quot;<span style="font-family: 'Courier New'; ">newSetFromMap(Map&lt;E,Boolean&gt; map)</span>&quot; method available in <span style="font-family: 'Courier New'; ">java.util.Collections</span> class. In order to be compatible with JDK 5 the behavior of this the JDK 6 method had to be implemented as part of Tailgate portlet.&nbsp;</p> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">This way as soon as portlet session gets garbage collected there are no hard references to the buffer and it is collected as well. When all buffers are garbage collected the <span style="font-family: 'Courier New'; ">FileMonitor</span> thread ends. The first request instantiating new buffer will start new <span style="font-family: 'Courier New'; ">FileMonitor</span> thread which will again run as long as there is someone interested in receiving results.&nbsp;</p> <h2><b><span style="font-size: medium; ">Conclusion</span></b></h2> <p style="margin-top: 0px; margin-right: 0px; margin-bottom: 0.75em; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; text-align: justify; ">I'm well aware I'm not writing anything really revealing here. But after spending some hours on Tailgate portlet I thought I would write about the problems and solutions. Hopefully you at least learned a little something from this experience. In case you are interested,&nbsp;<a href="http://github.com/azzazzel/Liferay-plugins/tree/master/tailgate/">Tailgate's source code is available at GitHub.</a>&nbsp;</p>
