---
layout: post
title: ATG session tracking cookies and subdomains.
date: '2009-01-29 14:50:58 +0100'
mt_id: 7
blog_id: 1
post_id: 7
basename: atg_session_tracking_cookies_and_subdomains
categories:
- atg
- tips_and_tricks
---
<p style="text-align: justify;">If an ATG based web application is available under few subdomains (domain.com, www.domain.com, shop.domain.com) keeping track of session cookies across subdomains may be a challenge. Session tracking cookies (like jsessionid) usually do not have domain property set, which means they are sent back to exactly the same host they came from. So if visitors switch to another subdomain while navigating through the application they would most likely end up having a new session. Depending on what information session holds, the number of visitors and how many simultaneous sessions the server can handle, this may or may not be a problem.</p>

<!--more-->

<p style="text-align: justify;">The best solution is obviously not to let your visitors change the domain while browsing you site (for example by using relative links only). But if your application occupies the whole domain it may be easier and safer to set the domain property for all relevant cookies. Depending on what ATG modules you use, a number of cookies used for session tracking may vary.</p> <p style="text-align: justify;">Here is how this can be done on ATG 2006.3 running on JBoss 4.0.3.Since JBoss uses Tomcat as web container, we will add a valve to server.xml in which we'll replace a original <code>HttpServeltResponse</code> with custom wrapper. Actually this is a slightly modified version of the solution described here <a href="https://jira.jboss.org/jira/browse/JBWEB-107">https://jira.jboss.org/jira/browse/JBWEB-107</a>. So here is our valve:</p> <p><code class="block">  public class CookieRewriteValve extends ValveBase { <br /> &nbsp;&nbsp;&nbsp; private String domain = null;<br /> &nbsp;&nbsp;&nbsp; private String cookieNames = null;<br /> &nbsp;&nbsp;&nbsp; private Set cookiesToModify = null;<br /> <br /> &nbsp;&nbsp;&nbsp; public void postRegister(Boolean registrationDone) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (registrationDone.booleanValue()) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (cookieNames != null &amp;&amp; cookieNames.trim().length() &gt; 0) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cookiesToModify = new HashSet(Arrays.asList(cookieNames.toUpperCase().split(&quot;,\\s*&quot;)));<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public void invoke(Request request, Response response) throws IOException, ServletException {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CookieModifier.createThreadInstance(cookiesToModify, path, domain, secure, maxAge);<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; response = new CookieRewriteResponseWrapper(response);<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; request.setResponse(response);<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; getNext().invoke(request, response);<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public String getDomain() {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return domain;<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public void setDomain(String domain) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this.domain = domain;<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public String getCookieNames() {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return cookieNames;<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public void setCookieNames(String cookieNames) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this.cookieNames = cookieNames;<br /> &nbsp;&nbsp;&nbsp; }<br /> }   </code></p> <p>It has to be registered in &quot;Engine&quot; section of <code>&lt;PATH_TO_JBOSS&gt;/server/&lt;SERVER_NAME&gt;/deploy/jbossweb-tomcat55.sar/server.xml</code> like this</p> <p><code class="blockWhite"> &lt;Valve domain=&quot;.domain.com&quot; cookieNames=&quot;jsessionid, ATG_SESSION_ID&quot; className=&quot;cookie.rewrite.example.CookieRewriteValve&quot;/&gt;</code></p> <p style="text-align: justify;">At startup engine initializes declared valves and calls <code>postRegister</code> method on each. This is where we read, parse and store arguments. Later on the <code>invoke</code> method is called by the engine on every incoming request. This is where we create a new thread local instance of <code>CookieModifier</code> and wrap the original <code>Response</code> in <code>CookieRewriteResponseWrapper</code>. This wrapper is constructed by passing a reference to the original <code>Response</code>:</p> <p><code class="block"> public class CookieRewriteResponseWrapper extends org.apache.catalina.connector.Response<br /> <br /> &nbsp;&nbsp;&nbsp; protected Response res;<br /> <br /> &nbsp;&nbsp;&nbsp; public CookieRewriteResponseWrapper(Response res) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this.res = res;<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; ....<br /> </code></p> <p style="text-align: justify;">It also overwrites EVERY public method from <code>org.apache.catalina.connector.Response</code> like this:</p> <p><code class="block"> &nbsp;&nbsp;&nbsp; public returnType methodName (parameters...) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return res.methodName (parameters...)<br /> &nbsp;&nbsp;&nbsp; }<br /> </code></p> <p style="text-align: justify;">except the <code>addCookie(Cookie cookie)</code> method which tries to get an instance of <code>CookieModifier</code> and use it to modify the cookie before it delegates the request to the original <code>Response</code> object:</p> <p><code class="block"> &nbsp;&nbsp;&nbsp; public void addCookie(Cookie cookie) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CookieModifier cookieModifier = CookieModifier.getInstance();<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (cookieModifier != null) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cookieModifier.modify(cookie);<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; res.addCookie(cookie);<br /> &nbsp;&nbsp;&nbsp; }<br /> </code></p> <p style="text-align: justify;">Finally here is how <code>CookieModifier</code> looks like:</p> <p><code class="block"> public class CookieModifier {<br /> <br /> &nbsp;&nbsp;&nbsp; protected String cookieDomain;<br /> &nbsp;&nbsp;&nbsp; protected Set cookiesToModify = null;<br /> &nbsp;&nbsp;&nbsp; protected boolean modifyAll = false;<br /> <br /> &nbsp;&nbsp;&nbsp; private static ThreadLocal threadInstance = new ThreadLocal();<br /> <br /> &nbsp;&nbsp;&nbsp; private CookieModifier(Set cookiesToModify, String cookieDomain) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this.cookieDomain = cookieDomain;<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this.cookiesToModify = cookiesToModify;<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (cookiesToModify == null || cookiesToModify.isEmpty()) modifyAll = true;<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public static void createThreadInstance(Set cookiesToModify, String cookieDomain) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; threadInstance.set(new CookieModifier(cookiesToModify, cookieDomain));<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public static CookieModifier getInstance() {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return (CookieModifier) threadInstance.get();<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public void modify(Cookie cookie) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (modifyAll || cookiesToModify.contains(cookie.getName()))<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (cookieDomain != null) cookie.setDomain(cookieDomain);<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> }<br /> </code></p> <p style="text-align: justify;">Note the static methods used to store a new instance of this class in current thread.&nbsp; It will become clear why this is important later.</p> <p style="text-align: justify;">So all we have to do now is to pack these classes in a jar file, place it in <code>&lt;PATH_TO_JBOSS&gt;/server/&lt;SERVER_NAME&gt;/lib</code> and add the valve line to <code>server.xml</code>. But if you try to run this, you will notice that while it works for &quot;jsessionid&quot; it does not for &quot;ATG_SESSION_ID&quot;. This is because ATG itself wraps the <code>Response</code> object in DynamoHttpServletResponse which apparently does not make use of the original <code>addCookie</code> method! Fortunately though, ATG allows user to have custom implementations of <code>DynamoHttpServletResponse</code>. To tell ATG we have a custom implementation we need to add the following configuration to <code>/atg/dynamo/servlet/dafpipeline/DynamoHandler</code> component:</p> <p><code class="blockWhite"> responseClass=cookie.rewrite.example.DynamoHttpServletResponseWrapper </code></p> <p style="text-align: justify;">Now when ATG needs to create <code>DynamoHttpServletResponse</code> it will actually create an instance of <code>DynamoHttpServletResponseWrapper</code>. But how can our implementation obtain access to appropriately configured instance of <code>CookieModifier</code>? It can do so because our <code>CookieRewriteValve</code>, executed earlier in the same thread, placed an instance of <code>CookieModifier</code> in thread local variable. Here is how <code>DynamoHttpServletResponseWrapper</code> looks like:</p> <p><code class="block"> public class DynamoHttpServletResponseWrapper extends DynamoHttpServletResponse {<br /> <br /> &nbsp;&nbsp;&nbsp; public void addCookie(Cookie cookie) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CookieModifier cookieModifier = CookieModifier.getInstance();<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (cookieModifier != null) {<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cookieModifier.modify(cookie);<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; super.addCookie(cookie);<br /> &nbsp;&nbsp;&nbsp; }<br /> } </code></p> <p>That's it.&nbsp; Once we add this class to the jar created earlier and restart JBoss it should work like a charm ;)</p>
